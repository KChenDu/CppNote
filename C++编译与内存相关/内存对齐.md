1. 什么是内存对齐：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置进行限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。编译器将程序中的每个`数据单元`的地址安排在机器字的整数倍的地址指向的内存之中。
2. 为什么要内存对齐：主要是由于`CPU`的访问内存的特性决定，`CPU`访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由`CPU`数据总线宽度决定的。内存对齐的主要目的是为了减少`CPU`访问内存的次数，加大`CPU`访问内存的吞吐量。`CPU`始终以字长访问内存，如果不进行内存对齐，很可能增加`CPU`访问内存的次数。
	除了能够减少内存访问次数，增加内存读取的吞吐量以外，还有其他原因：
	- 比如某些特定的硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常，比如对于`CPU`中`SIMD`指令，则必须要求内存严格对齐
	- 每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的。某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作，因此此时`CPU`需要可能需要读取多次内存，这样就破坏了变量的原子性
	- 相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间，提高内存的访问效率，因为`CPU`在读取内存时，是一块一块的读取
	- 某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱
	- 某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。
3. 内存对齐的原则：
	结构体中的变量对齐的基本规则如下：
	- 结构体变量的首地址能够被其最宽的基本类型成员的长度和对齐基数二者中的较小者所整除
	- 结构体中的`static`成员变量不占用结构体的空间，由于静态成员变量在程序初始化时已经在静态存储区分配完成，所有该结构体实例中的静态成员都指向同一个内存区域
	- 结构体每个成员相对于结构体首地址的偏移量都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节
	- 结构体的总大小为结构体中最宽基本类型成员的长度与对齐基数二者中的较小者的整数倍，如有需要编译器会在最末尾的成员之后加上填充字节

[[C++编译与内存相关/readme|返回]]