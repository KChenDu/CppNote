1. 为什么需要编译：将编写好的代码翻译为机器可执行的二进制指令。
2. 编译的处理过程：
	编译预处理->编译->汇编->链接
	```mermaid
	flowchart
	    .c((源程序.c)) --> 预处理器
		预处理器 -->|修改了的源程序.i| 编译器
		编译器 -->|汇编程序.s| 汇编器
		.o((.o)) --> 连接器
		汇编器 -->|可重定位目标程序.o| 连接器
		连接器 --> 可执行程序((可执行程序))
	```
	- **编译预处理**：引入头文件`#include`，去除注释，处理条件编译指令（`#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`），宏的替换（`#define`），添加行号，保留所有的编译器指令；
	- **编译**：进行词法分析、语法分析、语义分析、符号汇总、汇编代码生成，并针对程序的结构或者特定的CPU平台进行优化；
	- **汇编**：将汇编代码`.s`翻译成机器指令`.o`文件，一个`.cpp`文件只会生成一个`.o`文件；
	 - **链接**：文件A中的函数引用了另一个文件B中定义的符号或者调用了某个库文件中的函数，这就需要链接处理。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成一个可被操作系统加载执行的ELF程序文件。
3. 静态链接与动态链接：
	- **静态链接**：在生成可执行文件时，将该程序所需要的全部外部调用函数全部拷贝到最终的可执行程序文件中，在该程序被执行时，该程序运行时所需要的全部代码都会被装入到该进程的虚拟地址空间中。
	```mermaid
	flowchart LR
		subgraph 静态链接库
	    code1[代码]
	    end
		subgraph 可执行程序
	    code2[代码]
	    end
	    code1 -->|拷贝| code2
		subgraph 程序
		subgraph 虚拟地址空间
	    code3[代码]
	    end
	    end
		可执行程序 -->|执行| 程序
	```
	- **动态链接**：在生成可执行文件时，该程序所调用的部分程序被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息，最终生成的ELF文件中并不包含这些调用程序二进制指令。在程序执行时，当需要调用这部分程序时，操作系统会从将这些动态链或者共享对象进行加载，并将全部内容会被映射到该进行运行的虚拟地址的空间。
	```mermaid
	flowchart LR
		subgraph 动态链接库
	    code1[代码]
	    end
		subgraph 共享程序
		subgraph 虚拟地址空间
	    code2[代码]
	    end
	    end
		动态链接库 -->|执行| 共享程序
		program1[程序] -->|映射| code2
		program2[程序] -->|映射| code2
	```
	- **二者的优缺点**：
	
		|| **空间** | **更新** | **速度**
		| ------ | ----- | ---- | ----
		| **动态链接** | 节省 | 方便 | 损失
		| **静态链接** | 浪费 | 困难 | 快
[返回](readme.md)