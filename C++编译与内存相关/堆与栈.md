1. 栈：每次在调用函数时，会按照从右向左的顺序依次将函数调用参数压入到栈中，并在栈中压入返回地址与当前的栈帧，然后跳转到调用函数内部，`pc`跳转函数内部执行该函数的指令。
	![[imgs/stack.png]]
	- **栈溢出**：在实际编写程序时，如果出现两个函数互相调用或者递归无退出条件时，此时栈空间的就会无限增长。
	栈一般还分为内核栈与用户栈，在栈顶会有一个特殊的内存页`guard`，当栈一旦越界访问该特殊的`guard`页时，则会出现栈溢出的错误。
2. 堆：当程序在运行时，需要动态申请额外的内存来存放相应的数据和变量，此时就需要用到堆。堆的内存空间一般由操作系统或者专门内存程序来管理的。在`C++`一般用`new`来从堆中申请内存，使用`delete`来释放空间，空间释放后会有操作系统进行回收。
3. 堆与栈的优缺点：
	- **申请方式**：栈中存放的变量在编译时由编译器为其在栈上分配了空间，即程序编译后该变量在栈中使用的内存即确定，释放时也由于函数调用的返回，栈的空间会自动进行回收。堆中存放的变量由程序运行时决定的，会有操作系统或者内存管理模块来进行分配的。
	- **申请后系统响应**：
		- 分配栈空间时如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出，且当函数返回时，当前栈帧中的变量生存周期会结束；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上，如果不对申请的内存进行释放，则堆上存储的变量生存周期一直存在，直到当前进程退出。
		- 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，且只能被当前的线程访问；堆在内存中的空间（向高地址扩展）是不连续的，中间允许有间隔，堆中的内存并不是线程安全的，同一进程的线程都都可访问。
	- **申请效率**：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
	- **存放的内容**：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。
4. 实际的内存管理
	实际的内存管理可能更为复杂，一般分为两级内存管理。
	- 操作系统按照段页式来管理内存，当需要创建新的进程或者线程时，操作系统会为新创建的进程分配物理页，当运行的进程需要更多的内存时，操作系统也会为其分配新的物理页并将其映射到该进程的虚拟地址空间中。
	- 程序运行时，每个程序都含有一个内存管理的子程序，专门负责程序中的内存申请和释放。

[[C++编译与内存相关/readme|返回]]